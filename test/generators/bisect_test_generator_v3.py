# SPDX-FileCopyrightText: (c) 2021 Art—ëm IG <github.com/rtmigo>
# SPDX-License-Identifier: MIT

import datetime
from bisect import bisect_right, bisect_left, bisect
from pathlib import Path
from typing import Optional, Callable

named_arrays = {
    'A': [],
    'B': [4],
    'C': [4, 5],
    'D': [3, 4, 5],
    'E': [0, 1, 2, 2, 2, 2, 3, 3, 5, 6]
}

def index(a, x, lo, hi):
    'Locate the leftmost value exactly equal to x'
    i = bisect_left(a, x, lo=lo, hi=hi)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError


def find_lt(a, x):
    'Find rightmost value less than x'
    i = bisect_left(a, x)
    if i:
        return a[i - 1]
    raise ValueError


def find_le(a, x):
    'Find rightmost value less than or equal to x'
    i = bisect_right(a, x)
    if i:
        return a[i - 1]
    raise ValueError


def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError


def find_ge(a, x):
    'Find leftmost item greater than or equal to x'
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError




class TestFile:
    def __init__(self, name: str):
        self.name = name
        self.path = Path(__file__).parent.parent/"generated"/(name+".dart")

    def __enter__(self):
        self.file = self.path.open("wt")
        self.file.write(
            f"// Generated by {Path(__file__).name} at {datetime.datetime.now()}")

        self.file.write("""
            import 'package:bisection/bisection.dart';
            import 'package:test/test.dart';

            void main() {
        """)

        for name, arr in named_arrays.items():
            self.file.write(f'var {name} = {arr};')
        return self

    def __exit__(self, _, __, ___):
        self.file.write("}")
        self.file.flush()
        self.file.close()

class NamedTest:
    def __init__(self, file: TestFile, name: str):
        self.name = name
        self.test_file = file

    def __enter__(self):
        self.test_file.file.write(f"\ntest('{self.name}', () " + "{")

    def __exit__(self, _, __, ___):
        self.test_file.file.write("});")


def dart_call(object_name: Optional[str],
              func_name: str,
              *args,
              **kwargs):
    result = []
    if object_name:
        result.append(object_name + ".")
    result.append(func_name)
    result.append('(')

    dargs = [", ".join(str(a) for a in args),
             ", ".join(str(k) + ':' + str(a) for (k, a) in kwargs.items() if a is not None)]
    dargs = [a for a in dargs if a]

    result.append(", ".join(dargs))
    result.append(')')
    return ''.join(result)


if __name__ == "__main__":

    def gen_one(outfile: TestFile,
                test_name, gen_dart_call: Callable, python_func, hi, lo,
                wrap_dart_call: Callable = None):
        for arr_name in named_arrays.keys():
            with NamedTest(outfile, f"{test_name} for {arr_name} lo={lo} hi={hi}"):
                for x in range(-2, 9):
                    dart_call_code = gen_dart_call(arr_name, x, lo, hi)
                    if wrap_dart_call:
                        dart_call_code = wrap_dart_call(dart_call_code, arr_name)
                    dart_prefix = ''
                    try:
                        python_result = python_func(arr_name, x, lo, hi)
                        if python_result is None:
                            python_result = "null"
                    except IndexError:
                        dart_prefix = "()=>"
                        python_result = "throwsRangeError"
                    except ValueError:
                        dart_prefix = "()=>"
                        python_result = "throwsArgumentError"
                    outfile.file.write(
                        f"  expect({dart_prefix}{dart_call_code}, {python_result});\n")


    def gen_hilo_range(
            outfile: TestFile,
            test_name: str, gen_dart_call: Callable, python_func):
        hi_lo_ranges = [None] + list(range(0, 10))
        for hi in hi_lo_ranges:
            for lo in hi_lo_ranges:
                gen_one(outfile, test_name=test_name, gen_dart_call=gen_dart_call,
                        python_func=python_func, lo=lo, hi=hi)

    def null_to_zero(x):
        if x is not None:
            return x
        else:
            return 0

    with TestFile('bisect_left') as f:
        gen_hilo_range(
            f,
            'bisect_left',
            gen_dart_call=lambda arr_name, x, lo, hi:
                dart_call(None, "bisect_left", arr_name, x, lo=lo, hi=hi),
            python_func=lambda arr_name, x, lo, hi:
                bisect_left(named_arrays[arr_name], x, lo=null_to_zero(lo), hi=hi))

    # gen_hilo_range(
    #     'list.bisectLeft',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(arr_name, "bisectLeft", x, low=lo, high=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         bisect_left(named_arrays[arr_name], x, lo=null_to_zero(lo), hi=hi))
    #
    # gen_hilo_range(
    #     'bisect_right',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "bisect_right", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         bisect_right(named_arrays[arr_name], x, lo=null_to_zero(lo), hi=hi))
    #
    # gen_hilo_range(
    #     'list.bisectRight',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(arr_name, "bisectRight", x, low=lo, high=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         bisect_right(named_arrays[arr_name], x, lo=null_to_zero(lo), hi=hi))
    #
    # gen_hilo_range(
    #     'bisect',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "bisect", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         bisect(named_arrays[arr_name], x, lo=null_to_zero(lo), hi=hi))
    #
    # gen_hilo_range(
    #     'index',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "index", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         index(named_arrays[arr_name], x, lo=null_to_zero(lo), hi=hi))
    #
    # gen_one(
    #     'find_lt',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "find_lt", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_lt(named_arrays[arr_name], x),
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'find_le',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "find_le", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_le(named_arrays[arr_name], x),
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'find_gt',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "find_gt", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_gt(named_arrays[arr_name], x),
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'find_ge',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(None, "find_ge", arr_name, x, lo=lo, hi=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_ge(named_arrays[arr_name], x),
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'bsearchGreaterThan',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(arr_name, "bsearchGreaterThan", x, low=lo, high=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_gt(named_arrays[arr_name], x),
    #     wrap_dart_call=lambda code, arr_name: f'{arr_name}[{code}]',
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'bsearchLessThan',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(arr_name, "bsearchLessThan", x, low=lo, high=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_lt(named_arrays[arr_name], x),
    #     wrap_dart_call=lambda code, arr_name: f'{arr_name}[{code}]',
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'bsearchLessThanOrEqualTo',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(arr_name, "bsearchLessThanOrEqualTo", x, low=lo, high=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_le(named_arrays[arr_name], x),
    #     wrap_dart_call=lambda code, arr_name: f'{arr_name}[{code}]',
    #     hi=None, lo=None)
    #
    # gen_one(
    #     'bsearchGreaterThanOrEqualTo',
    #     gen_dart_call=lambda arr_name, x, lo, hi:
    #         dart_call(arr_name, "bsearchGreaterThanOrEqualTo", x, low=lo, high=hi),
    #     python_func=lambda arr_name, x, lo, hi:
    #         find_ge(named_arrays[arr_name], x),
    #     wrap_dart_call=lambda code, arr_name: f'{arr_name}[{code}]',
    #     hi=None, lo=None)
    #
    # print("}")
